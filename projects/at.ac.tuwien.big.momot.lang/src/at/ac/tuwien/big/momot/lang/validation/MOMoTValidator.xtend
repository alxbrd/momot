/*
 * generated by Xtext
 */
package at.ac.tuwien.big.momot.lang.validation

import at.ac.tuwien.big.moea.search.algorithm.provider.IRegisteredAlgorithm
import at.ac.tuwien.big.momot.ModuleManager
import at.ac.tuwien.big.momot.lang.mOMoT.AlgorithmList
import at.ac.tuwien.big.momot.lang.mOMoT.AlgorithmReferences
import at.ac.tuwien.big.momot.lang.mOMoT.AlgorithmSpecification
import at.ac.tuwien.big.momot.lang.mOMoT.ExperimentOrchestration
import at.ac.tuwien.big.momot.lang.mOMoT.FitnessDimensionOCL
import at.ac.tuwien.big.momot.lang.mOMoT.MOMoTPackage
import at.ac.tuwien.big.momot.lang.mOMoT.MOMoTSearch
import at.ac.tuwien.big.momot.lang.mOMoT.SaveAnalysisCommand
import at.ac.tuwien.big.momot.lang.mOMoT.SaveObjectivesCommand
import at.ac.tuwien.big.momot.lang.mOMoT.SearchOrchestration
import at.ac.tuwien.big.momot.lang.mOMoT.TransformationOrchestration
import com.google.inject.Inject
import java.util.ArrayList
import java.util.HashSet
import java.util.List
import java.util.Map
import org.eclipse.core.resources.IFile
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.runtime.Path
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.henshin.model.resource.HenshinResourceSet
import org.eclipse.ocl.ParserException
import org.eclipse.ocl.ecore.OCL
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.xbase.XExpression
import org.eclipse.xtext.xbase.XbasePackage
import org.eclipse.xtext.xbase.controlflow.EarlyExitInterpreter
import org.eclipse.xtext.xtype.XImportDeclaration
import org.moeaframework.algorithm.NSGAII
import org.eclipse.emf.common.util.URI

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MOMoTValidator extends AbstractMOMoTValidator {
	
	@Inject EarlyExitInterpreter interpreter
	
	override protected addImportUnusedIssues(Map<String, List<XImportDeclaration>> imports) {
		 super.addImportUnusedIssues(imports)
	}
	
	def interpret(XExpression expression) {
		try {
			return interpreter.evaluate(expression)
		} catch(Exception e) {
			e.printStackTrace
		}
		return null
	}
	
	val wsRoot = ResourcesPlugin.workspace.root
	
	def project(EObject it) {
		val path = new Path(eResource?.URI.toPlatformString(true))
		wsRoot?.getFile(path)?.project
	}
	
	def projectMember(EObject it, String relativePath) {
		project?.findMember(relativePath)
	}
	
	def projectFileExists(EObject it, String relativePath) {
		val member = project?.findMember(relativePath)
		if(member == null)
			return false
		return member instanceof IFile && member.exists
	}
	
	@Check
	def checkNrRuns(ExperimentOrchestration it) {
		if(nrRuns == null)
			return
		val runs = nrRuns.interpret as Integer
		if(runs == null)
			return;
			
		if(runs < 30)
			warning("Since we are using heuristics, at least 30 runs should be given to avoid bias.",
				it,
				MOMoTPackage.Literals.EXPERIMENT_ORCHESTRATION__NR_RUNS
			)
	}
	
	@Check
	def checkNrIterations(ExperimentOrchestration it) {
		if(maxEvaluations == null || populationSize == null)
			return
		val eval = maxEvaluations.interpret as Integer
		val population = populationSize.interpret as Integer
		if(eval == null || population == null)
			return;
		
		val iterations = eval / population
		if(iterations < 10)
			warning("Running only " + iterations + " iterations (maxEvaluations / populationSize) may not be sufficient to " +
				"converge to a good search area, try at least 10 iterations, i.e., " + 10 * population + " maxEvaluations.",
				it,
				MOMoTPackage.Literals.EXPERIMENT_ORCHESTRATION__MAX_EVALUATIONS
			)
	}
	
	@Check
	def checkHenshinRules(TransformationOrchestration it) {
		if(it != null && modules != null) {
			val manager = new ModuleManager
			for(module : modules.elements) {
				val path = module.interpret as String
				if(path != null) {
					val fullPath = it.projectMember(path).fullPath.toString
					manager.addModule(fullPath)
				}
			}
			
			if(unitsToRemove != null) {
				var index = 0
				for(unit : unitsToRemove.elements) {
					val name = unit.interpret as String
					if(manager.getUnit(name) == null)
						error("Unit '" + name + "' does not exist in the specified modules.", unitsToRemove, XbasePackage.Literals.XCOLLECTION_LITERAL__ELEMENTS, index)
					index++
				}
			}
			
			if(parameterValues != null) {
				var index = 0
				for(p : parameterValues) {
					val name = p.name.interpret as String
					if(manager.getParameter(name) == null)
						error("Parameter '" + name + "' does not exist in the specified modules.", it, MOMoTPackage.Literals.TRANSFORMATION_ORCHESTRATION__PARAMETER_VALUES, index)
					index++
				}
			}
			
			if(nonSolutionParameters != null) {
				var index = 0;
				for(p : nonSolutionParameters.elements) {
					val name = p.interpret as String
					if(manager.getParameter(name) == null)
						error("Parameter '" + name + "' does not exist in the specified modules.", nonSolutionParameters, XbasePackage.Literals.XCOLLECTION_LITERAL__ELEMENTS, index)
					index++
				}
			}
		}
	}
	
	@Check
	def checkReferenceSet(ExperimentOrchestration it) {
		if(referenceSet != null) {
			val path = referenceSet.interpret as String
			if(path != null) {
				if(!it.projectFileExists(path))
					error("ReferenceSet file '" + path + "' does not exist.", it, MOMoTPackage.Literals.EXPERIMENT_ORCHESTRATION__REFERENCE_SET)
			}
		}
	}
	
	@Check 
	def checkOverride(SaveAnalysisCommand it) {
		if(it != null && file != null) {
			val path = file.interpret as String
			if(path != null) {
				if(it.projectFileExists(path))
					info("Analysis file '" + path + "' will be overridden.", it, MOMoTPackage.Literals.SAVE_ANALYSIS_COMMAND__FILE)
			}
		}
	}
	
	@Check 
	def checkOverride(SaveObjectivesCommand it) {
		if(it != null && file != null) {
			if(it.projectFileExists(file))
				info("Objective file '" + file + "' will be overridden.", it, MOMoTPackage.Literals.SAVE_OBJECTIVES_COMMAND__FILE)
		}
	}
	
	@Check(EXPENSIVE)
	def checkOCL(SearchOrchestration it) {
		if(it != null && model != null && fitnessFunction != null) {
			val path = model.interpret as String
			if(path != null) {
				val member = project?.findMember(path)
				if(!member.exists)
					return
				var EObject root
				try {
					for(objective : fitnessFunction.objectives) {
						if(objective instanceof FitnessDimensionOCL) {
							val ocl = OCL::newInstance
							val oclObjective = objective as FitnessDimensionOCL
							val helper = ocl.createOCLHelper
							if(root == null) {
								val set = new HenshinResourceSet
								val resource = set.getResource(member.fullPath.toString)
								root = resource.contents.get(0)
							}
							helper.context = root.eClass
							var index = 0
							try {
								for(def : oclObjective.defExpressions) {
									helper.defineAttribute(def.expression)
									index++
								}
							} catch(ParserException e) {
								error("OCL: " + e.localizedMessage, oclObjective, MOMoTPackage.Literals.FITNESS_DIMENSION_OCL__DEF_EXPRESSIONS, index)
							}
							
							try {
								val query = oclObjective.query.interpret as String
								helper.createQuery(query)
							} catch(ParserException e) {
								error("OCL: " + e.localizedMessage, oclObjective, MOMoTPackage.Literals.FITNESS_DIMENSION_OCL__QUERY)	
							}
						}
					}
				} catch(Exception e) {
					error("Error: " + e.localizedMessage, it, MOMoTPackage.Literals.SEARCH_ORCHESTRATION__MODEL)	
				}
			}
		}	
	}
	
	@Check
	def checkModules(TransformationOrchestration it) {
		var index = 0
		for(module : modules.elements) {
			val path = module.interpret as String
			if(path != null) {
				if(!it.projectFileExists(path))
					error("Module file '" + path + "' does not exist.", modules, XbasePackage.Literals.XCOLLECTION_LITERAL__ELEMENTS, index)
			}
			index++
		}
	}
	
	@Check
	def checkModel(SearchOrchestration it) {
		if(model != null) {
			val path = model.interpret as String
			if(path != null) {
				if(!model.projectFileExists(path))
					error("Model file '" + path + "' does not exist.", it, MOMoTPackage.Literals.SEARCH_ORCHESTRATION__MODEL)
			}
		}
	}

	@Check
	def checkDuplicateAlgorithms(AlgorithmList it) {
		val names = new HashSet
		val duplicates = new ArrayList
		for(spec : specifications) {
			if(names.contains(spec.name))
				duplicates.add(spec)
			names.add(spec.name)
		}
		
		for(spec : duplicates)
			error("Algorithm with duplicate name '" + spec.name + "'.", spec, MOMoTPackage.Literals.ALGORITHM_SPECIFICATION__NAME)
	}
	
	@Check
	def checkSaveAnalysis(MOMoTSearch it) {
		if(resultManagement != null && 
			resultManagement.saveAnalysis != null &&
			analysisOrchestration == null)
			error("Need to specify analysis to save it.", resultManagement, 
				MOMoTPackage.Literals.RESULT_MANAGEMENT__SAVE_ANALYSIS
			)
	}
	
	@Check
	def checkDuplicateAlgorithmReferences(AlgorithmReferences it) {
		val names = new HashSet
		val duplicates = new ArrayList
		for(spec : elements) {
			if(names.contains(spec.name))
				duplicates.add(spec)
			names.add(spec.name)
		}
		
		for(spec : duplicates)
			error("Algorithm with name '" + spec.name + "' specified multiple times.", it, MOMoTPackage.Literals.ALGORITHM_REFERENCES__ELEMENTS)
	}
	
	@Check
	def checkDuplicateParameterKeys(TransformationOrchestration it) {
		val names = new HashSet
		val duplicates = new ArrayList
		for(spec : parameterValues) {
			val name = spec.name.interpret as String
			if(name != null) {
				if(names.contains(name))
					duplicates.add(spec)
				names.add(name)
			}
		}
		
		for(spec : duplicates)
			error("Set value for parameter '" + interpreter.evaluate(spec.name) as String + "' multiple times.", spec, MOMoTPackage.Literals.PARMETER_VALUE_SPECIFICATION__NAME)
	}

	def getActualType(AlgorithmSpecification it) {
		var type = call.actualType
		if(type.isAssignableFrom(IRegisteredAlgorithm))
			type = type.typeArguments.get(0)
		return type	
	}

	def isNSGAII(AlgorithmSpecification it) {
		actualType.isSubtypeOf(typeof(NSGAII))
	}
	
	@Check
	def checkObjectives(SearchOrchestration search) {		
		val nrObjectives = search.fitnessFunction.objectives.size
		if(nrObjectives > 3) {
			for(algorithm : search.algorithms.specifications) {
				if(!algorithm.NSGAII)
					warning("Consider using NSGA-III for more than 3 objectives.", 
						algorithm, 
						MOMoTPackage.Literals.ALGORITHM_SPECIFICATION__CALL
					)
			}
		}
	}
}
