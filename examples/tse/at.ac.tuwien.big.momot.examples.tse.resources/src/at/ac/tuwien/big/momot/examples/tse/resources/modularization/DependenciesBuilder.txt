--** The input and output metamodels of the transformation can have several packages **--
module DepdendenciesBuilder;
create OUT : MM_Out from IN : MM_ATL, IN_Src : MM_Src, IN_Trg : MM_Trg;

---*** This HOT associates rules with bindings belonging to other rules. A rule is associated with
---*** a certain binding belonging to other rule when any of the SimpleInPatternElements used in
---*** the first rule has the same type as the type returned by the OCLExpression in the value part
---*** of the binding. (The value part of a binding is the RHS, which is then internally resolved)

---*** Differently from the original transformation used in the TSE paper, now we only need the
---*** ultimate type returned by the binding. This means, we do not care about the intermediate
---*** types that can appear in a long OCL expression

--*** Auxiliary sequence to keep the strings generated by called rule includeFeatures***--
helper def : auxSeq : Sequence(String) = Sequence{};
--*** Auxiliary sequence to store the features of a navigation by helper getTypesFromNavigation***--
helper def : featSeq : Sequence(String) = Sequence{};

helper def : bindingTypes : Sequence(String) = Sequence{};

helper def : classOne : MM_Src!EClass = OclUndefined;
helper def : classTwo : MM_Src!EClass = OclUndefined;

helper def : inMMName : Sequence(String) = Sequence{'class'};
helper def : outMMName : Sequence(String) = Sequence{'relational'};

--**********************************************************************************************--
	
--*********** Helpers for retrieving helpers (which are of type OperationCallExp when they
--*************************appear within a rule), their types, etc. *****************************--

helper def: isAHelper(a : MM_ATL!OclExpression) : Boolean =	
if a.oclIsUndefined()
    then false
	else if a.oclIsTypeOf(MM_ATL!OperationCallExp)
	   	 then if MM_ATL!Helper -> allInstances() -> exists (h|h.definition.feature.name=a.operationName)
			  then true
			  else false
			  endif
	     else if a.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
			  then if MM_ATL!Helper -> allInstances() -> exists (h|h.definition.feature.name=a.name)
				   then true
				   else false
				   endif
			  else false
			  endif	
		endif
endif;

helper context MM_ATL!OclExpression def: getHelper() : MM_ATL!Helper =
   	if self.oclIsTypeOf(MM_ATL!OperationCallExp)
	then MM_ATL!Helper -> allInstances() -> select (h|h.definition.feature.name=self.operationName) -> first() -- self is a OperationCallExp
	else MM_ATL!Helper -> allInstances() -> select (h|h.definition.feature.name=self.name) -> first() -- self is a NavigationOrAttributeCallExp
	endif
;


helper context MM_ATL!Helper def: getHelperReturnType() : String =
if (self.definition.feature.oclIsKindOf(MM_ATL!Attribute))
then self.definition.feature.type.elementType.name
else if (self.definition.feature.returnType.oclIsKindOf(MM_ATL!CollectionType))
	 then if (not self.definition.feature.returnType.elementType.name.oclIsUndefined())
	 	  then self.definition.feature.returnType.elementType.name
		  else 'String'
		  endif
     else if (not self.definition.feature.returnType.name.oclIsUndefined())
	      then self.definition.feature.returnType.name
	      else 'String'
	      endif
	 endif
endif;
	
helper context MM_ATL!Helper def: getHelperReturnModel() : String =
if self.definition.feature.oclIsKindOf(MM_ATL!Operation)
then if self.definition.feature.returnType.oclIsKindOf(MM_ATL!CollectionType)
	 then self.definition.feature.returnType.elementType.name
	 else self.definition.feature.returnType.model.name
	 endif
else self.definition.feature.type.elementType.name--It's of type MM_ATL!Attribute
endif
;	


--**********************************************************************************************--

--*********** Helpers for retrieving (unique) lazy rules (which are of type OperationCallExp when they
--*************************appear within a rule), their types, etc. *****************************--
helper def: isALazyRule(a : MM_ATL!OclExpression) : Boolean =	
if a.oclIsUndefined()
    then false
	else if a.oclIsTypeOf(MM_ATL!OperationCallExp)
	   	 then if MM_ATL!LazyMatchedRule -> allInstances() -> exists (l|l.name=a.operationName)
			  then true
			  else false
			  endif
	     else false
	endif
endif;
helper context MM_ATL!OclExpression def: getLazyRule() : MM_ATL!Helper =
   	MM_ATL!LazyMatchedRule -> allInstances() -> select (l|l.name=self.operationName) -> first()
	;
helper context MM_ATL!LazyMatchedRule def: getLazyRuleReturnType() : String =
'trg_'.concat(self.outPattern.elements->first().type.name);
--**********************************************************************************************--

--*********** Helpers for retrieving called rules (which are of type OperationCallExp when they
--*************************appear within a rule), their types, etc. *****************************--
helper def: isACalledRule(a : MM_ATL!OclExpression) : Boolean =	
if a.oclIsUndefined()
    then false
	else if a.oclIsTypeOf(MM_ATL!OperationCallExp)
	   	 then if MM_ATL!CalledRule -> allInstances() -> exists (l|l.name=a.operationName)
			  then true
			  else false
			  endif
	     else false
	endif
endif;
helper context MM_ATL!OclExpression def: getCalledRule() : MM_ATL!Helper =
   	MM_ATL!CalledRule -> allInstances() -> select (l|l.name=self.operationName) -> first()
	;
helper context MM_ATL!CalledRule def: getCalledRuleReturnType() : String =
'trg_'.concat(self.outPattern.elements->first().type.name);
--**********************************************************************************************--

helper context String def : isSimpleType() : Boolean =
	self = 'String' or self = 'Integer' or self = 'Boolean' or self = 'Double'
;

helper def: isAResolveTemp(a : MM_ATL!OclExpression) : Boolean =	
if a.oclIsUndefined()
    then false
	else if a.oclIsTypeOf(MM_ATL!OperationCallExp)
	   	 then if a.operationName = 'resolveTemp'
			  then true
			  else false
			  endif
	     else false
	endif
endif;

-- This helper is for not retrieving the NavigarionOrAttributeCallExps that are in a collect
-- iterator to which other iterators/NavigationorAttributeCallExp elements follow. This way, we get just 
-- a path from the beginning until the end. For example, if we have
-- "INMM!EClass.allInstances() -> collect(e|e.attributes.types) -> select(t|t.name='Int') -> collect(t|t.name)",
-- then we want the navigation backwards to start from "name", not from "types"
helper context MM_ATL!OclExpression def : collectWithFeatureFollowing() : Boolean =
if ((self.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp) or thisModule.isAHelper(self)) and not self.loopExp.oclIsUndefined())
then if (self.loopExp.name = 'collect' or self.loopExp.name = 'select') and not self.loopExp.appliedProperty.oclIsUndefined()
	 then if not self.loopExp.appliedProperty.oclIsKindOf(MM_ATL!OperationCallExp)
	 	  then true
		  else self.loopExp.appliedProperty.collectWithFeatureFollowingAux()
		  endif
	 else false
	 endif
else false
endif;
helper context MM_ATL!OclExpression def : collectWithFeatureFollowingAux() : Boolean =
if self.appliedProperty.oclIsUndefined()
then false
else if not self.appliedProperty.oclIsKindOf(MM_ATL!OperationCallExp)
	 then true
	 else self.appliedProperty.collectWithFeatureFollowingAux()
	 endif
endif;
--*****************************************************************************************************--

--******************* Helpers used to retrieve a set of elements (of type OclExpression)********************--	
helper context MM_ATL!LocatedElement def : collectAllContainedElements() : Set(OclAny) = 
	MM_ATL!OclExpression.allInstances() -> select(x|x.collectAllContainer().includes(self)).flatten();

helper context MM_ATL!LocatedElement def : collectAllContainer() : Set(OclAny) = 
	Set{self.refImmediateComposite()} -> union(
		if(self.refImmediateComposite().oclIsUndefined()) 
		then Set{} 
		else self.refImmediateComposite().collectAllContainer()
		endif).flatten() -> reject(x|x.oclIsUndefined());
--*********************************************************************************************************--

--***These helpers are used to, backwards, built the whole navigation path, traversing through iterators, helpers,
--****************************************and whatever they find************************************************-- 

--*** This helper can be called by either an OperationCallExp, which represents a Helper, or a 
--*** NavigationOrAttributeCallExp. The parameter, "name", is the name of the object in the context ***--
helper context MM_ATL!OclExpression def : getExpression(name : String) : String =
if self.oclIsTypeOf(MM_ATL!OclModelElement)
	then self.name
	else if self.source.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp) 
	then self.source.getExpression('.'.concat(self.source.name)).concat(name)
	  else if thisModule.isAHelper(self.source)
	       then self.source.getExpression('.'.concat(self.source.getHelper().getHelperReturnType())).concat(name)
		else if self.source.oclIsKindOf(MM_ATL!OperationCallExp) -- In case we have ops like flatten (there may be more than one in a row)
		 then if self.source.jumpOperationCallExp().oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
		 	  then self.source.jumpOperationCallExp().getExpression('.'.concat(self.source.jumpOperationCallExp().name)).concat(name)
			  else self.source.jumpOperationCallExp().getExpressionIt().concat(name)
			  endif
		 else if (self.source.oclIsKindOf(MM_ATL!LoopExp))
		 	 -- the features of the collect must be included in the path, but not for the other iterators
			 then if (self.source.name = 'collect')
			 	  --then self.source.getExpressionCollect().concat('.').concat(self.name)
				  then self.source.body.getExpression('.'.concat(self.source.body.name)).concat('.').concat(self.getHelper().getHelperReturnType())
				  else self.source.getExpressionIt().concat('.').concat(self.getHelper().getHelperReturnType())
				  endif
			 else if (self.source.oclIsTypeOf(MM_ATL!OclModelElement))
			 	  then 'src_'.concat(self.source.name)
		     	  else if	(self.source.referredVariable.oclIsTypeOf(MM_ATL!SimpleInPatternElement) 
		     	  				or self.source.referredVariable.oclIsTypeOf(MM_ATL!SimpleOutPatternElement)
								  or self.source.referredVariable.oclIsTypeOf(MM_ATL!Parameter))
		          	   then self.source.getExpressionSIPE().concat(name)
		     	  	   else if self.source.referredVariable.oclIsTypeOf(MM_ATL!Iterator)
		     	  	   		then if not self.source.referredVariable.loopExpr.oclIsUndefined()
	  			      	    	 then self.source.referredVariable.loopExpr.getExpressionIt().concat(name)
								 else ''
			           	    	  endif
							 else if thisModule.isAHelper(self) then self.getExpressionHelperType() else 'src_EObject' endif --Careful here
			 	  	   		 endif
				   	   endif
				  endif
			  endif
		  endif
	endif
endif
endif;

--*** This helper recevies an IteratorExp as input so its name does not have to be added in the path ***--
helper context MM_ATL!OclExpression def : getExpressionIt() : String =
if self.oclIsTypeOf(MM_ATL!OclModelElement)
	then self.name
	else if self.source.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp) 
	then self.source.getExpression('.'.concat(self.source.name))--.concat('.').concat(self.source.toString())
	 else if thisModule.isAHelper(self.source)
	       then self.source.getExpression('.'.concat(self.source.getHelper().getHelperReturnType()))
	else if self.source.oclIsKindOf(MM_ATL!OperationCallExp) -- In case we have ops like flatten (there may be more than one in a row)
		 then if self.source.jumpOperationCallExp().oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
		 	  --then self.source.jumpOperationCallExp().appliedProperty.getExpression('.'.concat(self.source.jumpOperationCallExp().appliedProperty.name))
			  then self.source.jumpOperationCallExp().appliedProperty.getExpressionIt()
			  else self.source.jumpOperationCallExp().appliedProperty.getExpressionIt()
			  endif
		 else if (self.source.oclIsKindOf(MM_ATL!LoopExp))
		 	   -- the features of the collect must be included in the path, but not for the other iterators
			  then if (self.source.name = 'collect')
			  	   then if self.source.body.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
				        then self.source.body.getExpression('.'.concat(self.source.body.name))
						else if thisModule.isAHelper(self.source.body)
						     then self.source.body.getExpression('.'.concat(self.source.body.getHelper().getHelperReturnType()))
							 else 'src_EObject'
							 endif
						endif
				   else self.source.getExpressionIt()
				   endif
			 else if (self.source.oclIsTypeOf(MM_ATL!OclModelElement))
			 	  then 'src_'.concat(self.source.name)
				  else if (self.source.oclIsKindOf(MM_ATL!CollectionExp))
				  	   then 'src_EObject'
					   else if	(self.source.referredVariable.oclIsTypeOf(MM_ATL!SimpleInPatternElement) 
		     	  				or self.source.referredVariable.oclIsTypeOf(MM_ATL!SimpleOutPatternElement)
								  or self.source.referredVariable.oclIsTypeOf(MM_ATL!Parameter))
		     	  	   		then self.source.getExpressionSIPE()--.concat('.').concat(self.source.toString())
					  		else if (self.source.referredVariable.oclIsTypeOf(MM_ATL!Iterator))
					   			 then if not self.source.referredVariable.loopExpr.oclIsUndefined()
								 	  then self.source.referredVariable.loopExpr.getExpressionIt()
								 	  else ''
									  endif
			      	   			 else if (self.source.referredVariable.oclIsTypeOf(MM_ATL!RuleVariableDeclaration))
			      	   			 	  then self.source.getExpressionSIPE()
								 	  else 'src_EObject'
								 	  endif
								endif
			           	    	endif
			 	  	   		 endif
				   	   endif
				  endif
			  endif
		  endif
	endif
endif;

helper context MM_ATL!OclExpression def : getExpressionHelperType() : String =
	if thisModule.inMMName -> includes(self.getHelper().getHelperReturnModel().toLowerCase())
	then 'src_'.concat(self.getHelper().getHelperReturnType())
	else 'trg_'.concat(self.getHelper().getHelperReturnType())
	endif
;

helper context MM_ATL!OclExpression def : getExpressionSIPE() : String =
	if self.referredVariable.oclIsTypeOf(MM_ATL!SimpleOutPatternElement)
	then 'trg_'.concat(self.referredVariable.type.name)
	else if self.referredVariable.oclIsTypeOf(MM_ATL!SimpleInPatternElement)
	     then 'src_'.concat(self.referredVariable.type.name)
		 else if self.referredVariable.oclIsTypeOf(MM_ATL!Parameter)
		 	  then let oclME : MM_ATL!OclModelElement = MM_ATL!OclModelElement.allInstances() -> select(o|o.variableDeclaration=self.referredVariable) -> first() 
		 			in if thisModule.inMMName -> includes(oclME.model.name.toLowerCase())
					   then 'src_'.concat(self.referredVariable.type.name)
					   else 'trg_'.concat(self.referredVariable.type.name)
					   		--oclME.model.name.concat('_'.concat(self.referredVariable.type.name))
					   endif
		 	  else ''
		 	  endif
		 endif
	endif
;

helper context MM_ATL!OclExpression def : jumpOperationCallExp() : MM_ATL!OclExpression =
	if self.oclIsKindOf(MM_ATL!OperationCallExp)
	then self.source.jumpOperationCallExp()
	else self
	endif
;
--*******************************************************************************************************************--
--*******************************************************************************************************************--
helper def : containedFeatSrc(nav : Sequence(String)) : Boolean =
	not MM_Src!EStructuralFeature.allInstances()  
			-> select (f|f.name = nav.at(2) and (f.eContainingClass.name = nav.first()))->first().oclIsUndefined()
;

helper def : containedFeatSuperClassSrc(nav : Sequence(String)) : Boolean =
	if MM_Src!EStructuralFeature.allInstances()  
			-> select (f|f.name = nav.at(2) and (MM_Src!EClass.allInstancesFrom('MM_Src') 
				-> select(c|c.name = nav.first()) 
				  -> first().eAllSuperTypes -> exists(c|c = f.eContainingClass)))->first() = OclUndefined
	then false
	else true
	endif
;

helper context MM_Src!EClass def : isSubClassOf (c : MM_Src!EClass) : Boolean =
	self.eAllSuperTypes -> includes(c)	
;
--****************** These helpers are used to get the type of a navigation***********************-- 
--** Ideally, only the first feature is the name of a class; then, the
--** remaining features in the navigations are EReferences, and the last one can be also
--** an attribute. Careful: a feature in any part of the sequence can be a class, when it
--** is the type returned from a helper for example. In that case, we should start the
--** navigation from that class. 
--** In the example: 'src_Type.owner.reference.name (where 'reference' is of type 'Reference' and 
--** 'name' is a string), we should get: 'src_Reference.name', 'src_Reference'. If 'name'
--** was a reference, for example of type 'Name', then we should get:
--** 'src_Reference.name', 'src_Reference', 'src_Name'. 

--** This helper receives a Sequence(String) with a navigation (output of helper "navigationFromClass"), 
--** and also receives either 'src_' or 'trg_'. It returns a sequence with the types as explained above**-- 
--** NOTE: When I use MM_Src.allInstances() or MM_Trg.allInstances() in order to retrieve for example 
--** the EClasses of the input and out metamodels, respectively, all the EClasses from all the metamodels
--** are retrieved, that is why I use the comparison with "thisModule.inMMName" and "thisModule.outMMName".
--** These variables keep the name of the packages of the input and output metamodels (in lower case)
helper def : getTypesFromNavigation(nav : Sequence(String), s : String) : Sequence(String) =

	if nav.isEmpty()
	then Sequence{}
	else if nav.size() = 1
		 then Sequence{s.concat(nav.first())}
		 else if s = 'src_'
	     	  then let ftr: MM_Src!EStructuralFeature = 
	     	  				if (nav.first()='EObject')
	     	  				then MM_Src!EStructuralFeature.allInstancesFrom('MM_Src') -- if nav.first() is the eContainingClass of nav.at(2):  
									-> select (f|f.name = nav.at(2)).debug('1 ')
							else if not MM_Src!EStructuralFeature.allInstancesFrom('MM_Src') -- if nav.first() is the eContainingClass of nav.at(2):  
									-> select (f|f.name = nav.at(2) and (f.eContainingClass.name = nav.first()))->first().oclIsUndefined()
								then  MM_Src!EStructuralFeature.allInstancesFrom('MM_Src')
				   					-> select (f|f.name = nav.at(2) and (f.eContainingClass.name = nav.first()))->first().debug('2 ')
									-- if the eContainingClass of nav.at(2) is a super class of nav.first():
	     	  			    	else if not MM_Src!EStructuralFeature.allInstancesFrom('MM_Src') -> select (f|f.name = nav.at(2) and (MM_Src!EClass.allInstances() 
	     	  			    		--else if not MM_Src!EStructuralFeature.allInstances() -> select (f|f.name = nav.at(2) and (MM_Src!EClassifier.allInstances()
									-> select(c|c.name = nav.first()) 
				  						-> first().eAllSuperTypes -> exists(c|c = f.eContainingClass)))->first().oclIsUndefined()
							    	 then MM_Src!EStructuralFeature.allInstancesFrom('MM_Src')  -> select (f|f.name = nav.at(2) and (MM_Src!EClass.allInstancesFrom('MM_Src') 
							     	-> select(c|c.name = nav.first()) 
				 						-> first().eAllSuperTypes -> exists(c|c = f.eContainingClass)))->first().debug('3 ')
							     	else --if the eContainingClass of nav.at(2) is a subclass of nav.first():
										let cc: MM_Src!EClass = MM_Src!EClass.allInstancesFrom('MM_Src') -> select(c|c.name = nav.first()) -> first()
										in 
										--	MM_Src!EStructuralFeature.allInstances() -> first()  
										MM_Src!EStructuralFeature.allInstancesFrom('MM_Src') -> select (f|f.name = nav.at(2)) -> first().debug('4 ')
											--and MM_Src!EClass.allInstancesFrom('MM_Src') -> select(c|c.isSubClassOf(cc) and
									    	--f.eContainingClass.name = c.name)) -> first()
											-- and c.isSubClassOf(cc)
								 	endif
								endif
							endif

			  		in if nav.size() = 2 --here, the last feature may be an EReference or an EAttribute
			  						 --these two are the ones that must be returned
			  	  	   then if (nav.first()='EObject')
			  	  	   	    then Sequence{}.debug('5 ')					   
					        else if ftr.oclIsUndefined() --for helpers whose output belongs to the outputMM
					        	 then Sequence{'src_'.concat(nav.first())}.debug('6 ')
					   			 else if ftr.oclIsTypeOf(MM_Src!EReference) --When we get a reference
						   	     	  --then Sequence{'src_'.concat(nav.first()).concat('.').concat(nav.at(2)),
						 			  --	  'src_'.concat(nav.first()), 'src_'.concat(ftr.eType.name)}
					   			 --- In the new version, I have commented the lines above and added the one below
					   			      then Sequence{'src_'.concat(ftr.eType.name)}.debug('7 ')
							     	  else if ftr.oclIsTypeOf(MM_Src!EAttribute) and not ftr.eType.oclIsTypeOf(MM_Src!EEnum) --When we get an attribute
							               then Sequence{'src_'.concat(nav.first()).concat('.').concat(nav.at(2)),
						 				    'src_'.concat(nav.first())}
							     	       --then Sequence{}.debug('8 ')
							          	   else Sequence{'src_'.concat(nav.first()).concat('.').concat(nav.at(2)), -- When we get an ennumerate
						 				   'src_'.concat(nav.first()), 'src_'.concat(ftr.eType.name)}
			  							  --Sequence{}.debug('9 ')
			  						 	   endif
							    	  endif
	     	  			   		endif
							endif
				       else	 --Sequence{nav.first()} -> union (thisModule.getTypesFromNavigation(Sequence{ftr.eType.name}
											--->union(nav.subSequence(3,nav.size())),'src_'))
							if ftr.oclIsUndefined()
							then thisModule.getTypesFromNavigation(Sequence{'EObject'}->union(nav.subSequence(3,nav.size())),'src_').debug('10 ')
							else thisModule.getTypesFromNavigation(Sequence{ftr.eType.name}->union(nav.subSequence(3,nav.size())),'src_').debug('11 ')
							endif
				       endif
	     	  else Sequence{'of output metamodel'} 
	     	  endif
		 endif
	endif
;

--** This helper takes a navigation of the form 'Class.ref.type.name' and stores it
--** in a Sequence: {Class, ref, type, name} ***********************************--
helper context String def : separateFeaturesNavigation() : Sequence(String) =
	if self.indexOf('.') < 1 then
		Sequence{self}
	else Sequence{self.substring(1,self.indexOf('.'))} -> union(self.substring(self.indexOf('.')+2, 
												self.size()).separateFeaturesNavigation()->flatten())
	endif
;

--** This helper receives a sequence of strings with a navigation (which is in fact
--** the output of helper 'separateFeaturesNavigation') and removes all the features
--** which are before the last class that appears in the sequence. For example, if it
--** receives {Class, type, reference, Property, name}, it returns {Property, name}
helper def : navigationFromClass(nav : Sequence(String)) : Sequence(String) =
	if nav.last().substring(1,1) = nav.last().substring(1,1).toUpperCase()
	then Sequence{nav.last()}
	else thisModule.navigationFromClass(nav.subSequence(1,nav.size()-1)) -> append(nav.last())
	endif
;
--**********************************************************************************************--
--**********************************************************************************************--



rule module2trafo {
	from
		m : MM_ATL!Module
	to 
		t : MM_Out!Trafo (
		 	name <- m.name,
		 	modules <- Sequence{module}
		),
		module : MM_Out!Module(
			name <- m.name,
			rules <- m.elements -> select(x|x.oclIsKindOf(MM_ATL!Rule))
		)
}

--** This rule obtains the types of the features in every kind of rule (called, matched, lazy, unique lazy)--**
rule Rule2Rule{
	from
		m : MM_ATL!Rule
	to 
		t : MM_Out!Rule (
			name <- m.name,
			-- In case of inheritance:
			inheritsFrom <- if(m.oclIsKindOf(MM_ATL!MatchedRule)) then m.superRule else OclUndefined endif
		)
	do{
		--t.rule <- m;
		--** Types of the SimpleInPatternElements **--
		if (not m.oclIsTypeOf(MM_ATL!CalledRule)){
			if(not m.inPattern.oclIsUndefined()){
		  	-- This retrieves (the names of) the types of the variables that appear in the inPattern
			t.inPattElTypes <- m.inPattern.elements -> collect(x|x.type).flatten() -> collect(x|'src_'.concat(x.name));
			}
		}

		
		--** Navigation paths in the outPattern **--
		if (not m.outPattern.oclIsUndefined()){				
			for (ope in m.outPattern.elements){
				for (bind in ope.bindings){
					thisModule.bindingTypes <- Sequence{};
					for (ie in bind.collectAllContainedElements().flatten()){
						thisModule.auxSeq <- Sequence{};
						thisModule.includeFeatures(ie);
						if (thisModule.auxSeq <> Sequence{}){
							thisModule.bindingTypes <- thisModule.bindingTypes -> append(thisModule.auxSeq);
						}
					}
					if (thisModule.bindingTypes -> size() > 0){
						t.bindingNavigations <- thisModule.bindingTypes->last();	
					}
				}
			}
		}
		
		

		--** For all the navigation paths of the bindings of output elements, stored in t.bindingNavigations, 
		--** we get their types and keep them in t.bindingTypes, which is to be returned --**
		--for (f in t.allNavigationPaths){
		--	t.allFootPrints <- thisModule.getTypesFromNavigation(thisModule.navigationFromClass
		--		(f.substring(5,f.size()).separateFeaturesNavigation()),f.substring(1,4));
		--}

		t.bindingNavigations.debug('bindingNavigations ');
		thisModule.bindingTypes <- Sequence{};
		for (f in t.bindingNavigations){
			thisModule.bindingTypes <- thisModule.bindingTypes -> union(thisModule.getTypesFromNavigation(thisModule.navigationFromClass
				(f.substring(5,f.size()).separateFeaturesNavigation()),f.substring(1,4)));
		}
		t.inPattElTypes.debug('inPattElTypes ');
		thisModule.bindingTypes.debug('bindingTypes ');
		
		--If a type that is in the bindingTypes is also in the inPattElTypes, I do not want to
		--consider it for the dependencies, since it would depend on itself (the dependencies are
		--established in the endpoint rule establishDependencies). For that reason, I do the
		--difference between thisModule.bindingTypes and t.inPattElTypes, and it is what is actually
		--stored in t.bindingTypes
		for (f in thisModule.bindingTypes){
			if (t.inPattElTypes -> excludes(f)){
				t.bindingTypes <- t.bindingTypes -> append(f).debug('f ');	
			}
		}
		t.bindingTypes.debug('bindingTypes2 ');
				
--		t.inPattElTypes.debug('inPatternsFinal');
--		t.bindingNavigations.debug('bindingNavigationsFinal');
--		t.bindingTypes.debug('bindingTypesFinal');

	}
}
	
--*** This endpoint rule is to establish the dependencies among rules. If the relationship "dependsOn" goes
--*** from Rule1 to Rule2, this means that, if we change Rule2, then we also have to change Rule1. Especifically,
--*** this means that the type of a binding of Rule1 is the same as the type of a SimpleInPatternElement of Rule2
endpoint rule establishDependencies(){
	do {
		for (r in MM_Out!Rule.allInstances()){
			for (r2 in MM_Out!Rule.allInstances() -> excluding(r)){
				if (r.bindingTypes->asSet() -> intersection(r2.inPattElTypes->asSet()) -> size() > 0){
					r.dependsOn <- r.dependsOn -> append(r2);	
				} else { --Otherwise, we check for subclasses and superclasses
				for (bt in r.bindingTypes){
					thisModule.classOne <- MM_Src!EClass.allInstancesFrom('MM_Src')
					   -> select(c|c.name = bt.substring(5,bt.size()))->first();
					for (ipet in r2.inPattElTypes){
						thisModule.classTwo <- MM_Src!EClass.allInstancesFrom('MM_Src')
							-> select(c|c.name = ipet.substring(5,ipet.size()))->first();
						if (not thisModule.classOne.oclIsUndefined() and not thisModule.classTwo.oclIsUndefined()){
							if (not r.dependsOn->includes(r2) and 
								(thisModule.classOne.isSubClassOf(thisModule.classTwo) or thisModule.classTwo.isSubClassOf(thisModule.classOne))){
									r.dependsOn <- r.dependsOn -> append(r2);	
							}
						}
					}
				}
			}
		}
	}
	}
}
--*********************************************************************************************************************--

--*********************************************************************************************************************--
--*** Called rule that receives an OCLExpression and creates a path (backwards) from it
--*** when it corresponds. The result is kept in thisModule.auxSeq *********************--
--*** This rule, together with helpers "getExpression", "getExpressionIt",
--*** and "getExpressionSIPE", deals with the extraction of the
--*** navigation paths, which can range from a couple of features until very long paths ---***
rule includeFeatures (ie : MM_ATL!OclExpression){
	do{
		if (thisModule.isALazyRule(ie)){ -- If it is a lazy rule, return the first element created by it
			thisModule.auxSeq <- ie.getLazyRule().getLazyRuleReturnType();
		} else if (thisModule.isACalledRule(ie)){ -- If it is a CalledRule, return its type
			thisModule.auxSeq <- ie.getCalledRule().getCalledRuleReturnType();
		-- The second condition next is to avoid to include features when an iteration follows. For example, in
		-- "s.ownedProperty.class -> select (e|e.name)"", where "s" is of type "Bank", we want to get: 
		-- "Bank.ownedProperty.class.name" instead of both "Bank.ownedProperty.class" and "Bank.ownedProperty.class.name".
		-- The last (third) condition is for not retrieving the NavigarionOrAttributeCallExps that are in a collect
		-- iterator to which other iterators/NavigationorAttributeCallExp elements follow. This way, we get just 
		-- a path from the beginning until the end. For example, if we have:
		-- "s.ownedProperty.class -> collect(e|e.attribute.type) -> collect(f|f.date)", the only path we want
		-- to retrieve is: "Bank.ownedProperty.class.attribute.type.date". For that reason, the navigation backwards
		-- has to start with "date".
		} else if (ie.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp) 
				and not ie.appliedProperty.oclIsKindOf(MM_ATL!LoopExp)--.debug(ie.type.name)
					and not ie.collectWithFeatureFollowing()){ 	
			if (not ie.source.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)){ 
				if (thisModule.isAHelper(ie.source)){ -- if it is preceded by a helper
					thisModule.auxSeq <- ie.source.getExpression('.'.concat(ie.source.getHelper().getHelperReturnType())).concat('.').concat(ie.name);--.concat(' 1from:').concat(ie.name);
				} else if (ie.source.oclIsKindOf(MM_ATL!OperationCallExp)
						and not ie.appliedProperty.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
						and not thisModule.isAHelper(ie.appliedProperty)){ 
							thisModule.auxSeq <- ie.source.getExpressionIt().concat('.').concat(ie.name);--.concat(' 2from:').concat(ie.name);
				--} else if (not ie.source.oclIsTypeOf(MM_ATL!CollectionOperationCallExp)){
				} else if (not ie.source.oclIsKindOf(MM_ATL!OperationCallExp) and not ie.source.oclIsKindOf(MM_ATL!IteratorExp)){
					if (ie.source.referredVariable.oclIsKindOf(MM_ATL!Iterator) 
						  -- to start from the last feature of a navigation. For example, if we have a.ownedType.name,
						  -- we want to take "name", but not "ownedType"
						  and not ie.appliedProperty.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
						   and not ie.appliedProperty.oclIsTypeOf(MM_ATL!CollectionOperationCallExp)
						   and not thisModule.isAHelper(ie.appliedProperty)){
						  -- This gets the expression when we have a collect with only one feature after
						  -- the iterator, for example: collect(e|e.name)
						  thisModule.auxSeq <- ie.getExpression('.'.concat(ie.name));--.concat(' 3from:').concat(ie.name);
					} else if (ie.source.referredVariable.oclIsTypeOf(MM_ATL!RuleVariableDeclaration)
						  -- to start from the last feature of a navigation. For example, if we have a.ownedType.name,
						  -- we want to take "name", but not "ownedType"
						  and not ie.appliedProperty.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
						   and not thisModule.isAHelper(ie.appliedProperty)){ 
						  thisModule.auxSeq <- ie.getExpression('.'.concat(ie.name));--.concat(' 4from:').concat(ie.name);
					} else if ((ie.source.referredVariable.oclIsTypeOf(MM_ATL!SimpleInPatternElement) 
						  or ie.source.referredVariable.oclIsTypeOf(MM_ATL!SimpleOutPatternElement)
						   or ie.source.referredVariable.oclIsTypeOf(MM_ATL!Parameter))
							--and  ie.appliedProperty.oclIsUndefined()){
							 and not ie.appliedProperty.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)){
						-- I removed the previous 2nd condition (and added the one which is now)
						-- in order to retrieve the condition of a declarative if when there is only
						-- a feature (e.g., s.name ='hi'); and also to start only from the last
						-- feature when there are more than one (e.g., s.ownedProperty.name = 'hi')
						thisModule.auxSeq <- ie.getExpression('.'.concat(ie.name));--.concat(' 5from:').concat(ie.name);
					}
				} 
			} else if (ie.appliedProperty.oclIsUndefined()){
				  thisModule.auxSeq <- ie.getExpression('.'.concat(ie.name));--.concat(' 6from:').concat(ie.name);
			} else if (not ie.appliedProperty.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
				and not thisModule.isAHelper(ie.appliedProperty)){
				  thisModule.auxSeq <- ie.getExpression('.'.concat(ie.name));--.concat(' 7from:').concat(ie.name);
			}
		} else if (ie.oclIsTypeOf(MM_ATL!OclModelElement)){
		--Very often, in the filter of a rule, it is checked if an element is of type/kind
		--a certain class, like in, for example, "oclIsTypeOf(SimpleUML!NamedElement)". Here,
		--NamedElement is contained in an object of type OclModelElement, from which we simply
		--need to retrieve the name
			     thisModule.auxSeq <- 'src_'.concat(ie.name);
			
		-- For the Helpers, we follow the same procedure as for NavigationOrAttributeCallExp objects,
		-- although the way of extracting helpers names is different, so that is why we rewrite almost
		-- the same piece of code here
		} else if (thisModule.isAHelper(ie) and not ie.appliedProperty.oclIsKindOf(MM_ATL!LoopExp)
						and not ie.collectWithFeatureFollowing()){
			if (not ie.getHelper().getHelperReturnType().isSimpleType()){
				  if (not ie.source.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)){ 
					 if (thisModule.isAHelper(ie.source)){ -- if it is preceded by a helper
						thisModule.auxSeq <- ie.source.getExpression('.'.concat(ie.source.getHelper().getHelperReturnType())).concat('.').concat(ie.getHelper().getHelperReturnType());--.concat(' from:').concat(ie.getHelper().getHelperReturnType());
					 } else if (ie.source.oclIsKindOf(MM_ATL!OperationCallExp)){ -- if it is preceded by an operation
						thisModule.auxSeq <- ie.source.getExpressionIt().concat('.').concat(ie.getHelper().getHelperReturnType());--.concat(' from:').concat(ie.getHelper().getHelperReturnType());
					 } else if (ie.source.referredVariable.oclIsKindOf(MM_ATL!Iterator) 
							-- to start from the last feature of a navigation. For example, if we have a.ownedType.name,
							-- we want to take "name", but not "ownedType"
							and not ie.appliedProperty.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
							and not ie.appliedProperty.oclIsTypeOf(MM_ATL!CollectionOperationCallExp)
							and not thisModule.isAHelper(ie.appliedProperty)){
						-- This gets the expression when we have a collect with only one feature after
						-- the iterator, for example: collect(e|e.name)
						thisModule.auxSeq <- ie.getExpression('.'.concat(ie.getHelper().getHelperReturnType()));--.concat(' from:').concat(ie.getHelper().getHelperReturnType());
					 } else if (ie.source.referredVariable.oclIsTypeOf(MM_ATL!RuleVariableDeclaration) 
								-- to start from the last feature of a navigation. For example, if we have a.ownedType.name,
								-- we want to take "name", but not "ownedType"
								and not ie.appliedProperty.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
								and not thisModule.isAHelper(ie.appliedProperty)){ 
						thisModule.auxSeq <- ie.getExpression('.'.concat(ie.getHelper().getHelperReturnType()));--.concat(' from:').concat(ie.getHelper().getHelperReturnType());
					 } else if ((ie.source.referredVariable.oclIsTypeOf(MM_ATL!SimpleInPatternElement) 
									or ie.source.referredVariable.oclIsTypeOf(MM_ATL!SimpleOutPatternElement)
								 	 or ie.source.referredVariable.oclIsTypeOf(MM_ATL!Parameter))
								--and  ie.appliedProperty.oclIsUndefined()){
								and not ie.appliedProperty.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)){
						-- I removed the previous 2nd condition (and added the one which is now)
						-- in order to retrieve the condition of a declarative if when there is only
						-- a feature (e.g., s.name ='hi'); and also to start only from the last
						-- feature when there are more than one (e.g., s.ownedProperty.name = 'hi')
						thisModule.auxSeq <- ie.getExpression('.'.concat(ie.getHelper().getHelperReturnType()));--.concat(' from:').concat(ie.getHelper().getHelperReturnType());
					}
				} else if (ie.appliedProperty.oclIsUndefined()){
						thisModule.auxSeq <- ie.getExpression('.'.concat(ie.getHelper().getHelperReturnType()));--.concat(' from:').concat(ie.getHelper().getHelperReturnType());
				} else if (not ie.appliedProperty.oclIsTypeOf(MM_ATL!NavigationOrAttributeCallExp)
							and not thisModule.isAHelper(ie.appliedProperty)){
						thisModule.auxSeq <- ie.getExpression('.'.concat(ie.getHelper().getHelperReturnType()));--.concat(' from:').concat(ie.getHelper().getHelperReturnType());
				}
			}
		}
	}
}
--******************************************************************************************************************--
--******************************************************************************************************************--